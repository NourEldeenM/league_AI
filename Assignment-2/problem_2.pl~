% process_grid/1 (input grid)
:- consult('data_process.pl').
:- consult('problem_1.pl').

% valid_move/2 ((x,y), visited, Energy)
valid_move((X,Y),Visited, E) :-
    \+ member((X,Y), Visited),
    X >= 0,
    Y >= 0,
    grid_size(R,C),
    X < R,
    Y < C,
    \+ obstacle(X,Y),
    E > 0.
% Movement rules with energy handling:
% Each move reduces energy by 1.

left((X,Y), (X,NewY), EIn, EOut) :-
    NewY is Y - 1,
    EOut is EIn - 1.

right((X,Y), (X,NewY), EIn, EOut) :-
    NewY is Y + 1,
    EOut is EIn - 1.

up((X,Y), (NewX,Y), EIn, EOut) :-
    NewX is X - 1,
    EOut is EIn - 1.

down((X,Y), (NewX,Y), EIn, EOut) :-
    NewX is X + 1,
    EOut is EIn - 1.

move(X, Y, NewX, NewY, Visited, EIn, EOut) :-
    Curr = (X,Y),
    (
        left(Curr, Next, EIn, EOut);
        right(Curr, Next, EIn, EOut);
        up(Curr, Next, EIn, EOut);
        down(Curr, Next, EIn, EOut)
    ),
    Next = (NewX, NewY),
    valid_move((NewX, NewY), Visited, EOut).

state(Position, VisitedDeliveries).

% End goal is to visit all delivery points
goal_state(VisitedDeliveries) :-
    findall((X,Y), delivery(X,Y), AllDeliveries),
    subset(AllDeliveries, VisitedDeliveries).

% calculates distance between two points
distance((X1,Y1),(X2,Y2),D) :-
    D is abs(X1-X2) + abs(Y1-Y2).

heuristic(state((X, Y), Visited), H) :-
    % find all points not visited & store them in RemainingDeliveries
    findall(
        (DX,DY),
        (delivery(DX,DY),
        \+ member((DX,DY), Visited)),
        RemainingDeliveries
    ),
     % if -> then ; else
    (RemainingDeliveries = [] -> H = 0; % if no remaining deliveries, then H = 0
    % else
    findall( % find all
        Dist,
        (
            member((DX,DY), RemainingDeliveries), % RemainginDeliveries
            distance((X,Y),(DX,DY),Dist) % distances
        ),
        Dists), % and store them in Ditsts list
    min_list(Dists, H) % extract min distance and store in H
    ).

